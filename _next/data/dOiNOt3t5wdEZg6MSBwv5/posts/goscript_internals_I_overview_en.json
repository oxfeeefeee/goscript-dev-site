{"pageProps":{"postData":{"id":"goscript_internals_I_overview_en","contentHtml":"<h2>Introduction</h2>\n<p>Goscript is a VM-based Golang implementation written in Rust. Goscript Internals will be a series of articles explaining Goscript's design. The intended audience are any experienced programmers who are interested in how Goscipt works--or, more generally--how a compiler/ a scripting language/ a Go implementation works. You don't need to have a background in compilers, Go or Rust but it does help if you do. This first article is a brief introduction of how a typed scripting language works, which may be boring to experts.</p>\n<p>Before we dive in, let's make a table of all the sub-projects:</p>\n<table>\n<thead>\n<tr>\n<th>Project</th>\n<th>Description</th>\n<th>Language</th>\n<th>Credit</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Parser</td>\n<td>turns source into AST</td>\n<td>Rust</td>\n<td>ported from Official Go</td>\n</tr>\n<tr>\n<td>Type Checker</td>\n<td>type deduction and more</td>\n<td>Rust</td>\n<td>ported from Official Go</td>\n</tr>\n<tr>\n<td>Codegen</td>\n<td>turns AST into bytecode</td>\n<td>Rust</td>\n<td>original work</td>\n</tr>\n<tr>\n<td>VM</td>\n<td>runs bytecode</td>\n<td>Rust</td>\n<td>original work</td>\n</tr>\n<tr>\n<td>Engine</td>\n<td>wrapper and native library</td>\n<td>Rust</td>\n<td>original work</td>\n</tr>\n<tr>\n<td>Std</td>\n<td>Standard library</td>\n<td>Go</td>\n<td>adapted from Go</td>\n</tr>\n</tbody>\n</table>\n<p>Let's get a big picture of how things work by looking into what happens with this simple program, when Goscript runs it:</p>\n<div class=\"remark-highlight\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    b <span class=\"token operator\">:=</span> <span class=\"token number\">2</span>\n    c <span class=\"token operator\">:=</span> a <span class=\"token operator\">+</span> b\n    <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// built-in function </span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<h3>The parser</h3>\n<p>The parser read the source code and turns it into an AST (<a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">Abstract Syntax Tree</a>)</p>\n<ul>\n<li>A hand-written tokenizer (<a href=\"https://github.com/oxfeeefeee/goscript/blob/master/parser/src/scanner.rs\">scanner.rs</a>) turns the source code to a list of tokens like this:</li>\n</ul>\n<div class=\"remark-highlight\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token string\">`</span>\n<span class=\"token string\">package, main, var, a, EQL, 1, ...</span>\n<span class=\"token string\">`</span>\n</code></pre></div>\n<ul>\n<li>A hand-written <a href=\"https://en.wikipedia.org/wiki/Recursive_descent_parser\">recursive descent</a> parser (<a href=\"https://github.com/oxfeeefeee/goscript/blob/master/parser/src/parser.rs\">parser.rs</a>) turns the list of tokens into a tree. This step might look magical, but in fact quite intuitive, it's just a recursive program, that try to build nodes of different types of statements and expressions, by matching the tokens it sees and the tokens it expects. The tree definition can be found here (<a href=\"https://github.com/oxfeeefeee/goscript/blob/master/parser/src/ast.rs\">ast.rs</a>). The AST of the above program would be something like this:\n<img src=\"/images/ast.jpeg\" alt=\"ast\"></li>\n</ul>\n<h3>The type checker</h3>\n<p>The main task of the type checker is type deduction, which means figuring out the exact types of variables, structs, functions etc. to provide type information for code generator and to catch more syntax errors. It does so by traversing the AST and enforcing the rules defined in the language specs. You can take a quick look at <a href=\"https://github.com/oxfeeefeee/goscript/blob/master/types/src/check/expr.rs\">expr.rs</a> and <a href=\"https://github.com/oxfeeefeee/goscript/blob/master/types/src/check/stmt.rs\">stmt.rs</a> to get a general idea of how it works.</p>\n<p>In the case of the above example, it deduces that the types of <code>a</code>, <code>b</code>, <code>a + b</code> and <code>c</code> are all <code>int</code>, and the type of <code>c == 3</code> is <code>bool</code>. it also checks that <code>assert</code> does accept one and only one <code>bool</code> argument.</p>\n<p>The type checker is the most complex part of the whole project, there is an Go official <a href=\"https://go.googlesource.com/example/+/HEAD/gotypes/go-types.md\">document</a> talking about it in detail. In addition to type deduction, it does <a href=\"https://github.com/oxfeeefeee/goscript/blob/master/types/src/check/resolver.rs\">identifier resolution</a>, <a href=\"https://github.com/oxfeeefeee/goscript/blob/master/types/src/constant.rs\">constant evaluation</a>, and the insignificant looking <a href=\"https://github.com/oxfeeefeee/goscript/blob/master/types/src/check/initorder.rs\">init order computation</a>.</p>\n<p>The result of a type checking pass is a syntax error free AST, and a very rich database of type info about the AST, which will be used for bytecode generation.</p>\n<h3>The code generator</h3>\n<p>The code generator traverses the AST again to generate runtime objects containing the bytecode. For the example above, it generates objects that logically look like this:</p>\n<div class=\"remark-highlight\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token string\">`</span>\n<span class=\"token string\">- Package Object (main)</span>\n<span class=\"token string\">    - Package member variable (a)</span>\n<span class=\"token string\">    - Package member function (constructor)</span>\n<span class=\"token string\">        - bytecode: </span>\n<span class=\"token string\">            // copy constant10 to register0, which is where \"a\" is</span>\n<span class=\"token string\">            DUPLICATE   |0  |-10 </span>\n<span class=\"token string\">            RETURN          </span>\n<span class=\"token string\">    - Package member variable (main)</span>\n<span class=\"token string\">        - bytecode:</span>\n<span class=\"token string\">            // copy constant7 to register0, which is where \"b\" is</span>\n<span class=\"token string\">            DUPLICATE       |0  |-7 </span>\n<span class=\"token string\">            // load from package8's 0th member, which is \"a\", to register2 </span>\n<span class=\"token string\">            LOAD_PKG        |2  |-8 |0</span>\n<span class=\"token string\">            // register1 = register2 + register0</span>\n<span class=\"token string\">            ADD             |1  |2  |0</span>\n<span class=\"token string\">            // register2 = (register1 == constant9)</span>\n<span class=\"token string\">            EQL             |2  |1  |-9</span>\n<span class=\"token string\">            // crash if register2 != true</span>\n<span class=\"token string\">            ASSERT          |...|2  </span>\n<span class=\"token string\">            RETURN </span>\n<span class=\"token string\">`</span>         \n</code></pre></div>\n<p>As you can see, Goscript abandoned the original stack-based VM in favor of a register-based one. Stack-based VM is intuitive to design, but less efficient. With a stack-based VM, the above <code>ADD</code> would probably need three extra instructions -- two \"PUSH\" and one \"POP\" -- to do the same job.</p>\n<p>In essence, code generator is just a translator, which translates a tree into a one dimension array, so that for the VM, instead of traversing a tree, which is totally doable but would be much less efficient, it only needs to deal with instructions on a virtual tape one by one, plus jumping back and force. The main part of the code is <a href=\"https://github.com/oxfeeefeee/goscript/blob/master/codegen/src/codegen.rs\">codegen.rs</a>.</p>\n<h3>The virtual machine</h3>\n<p>As stated above, the VM is just a big loop (<a href=\"https://github.com/oxfeeefeee/goscript/blob/master/vm/src/vm.rs\">vm.rs</a>) that processes instructions until they run out. All the instructions can be divided into three categories:</p>\n<div class=\"remark-highlight\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token string\">`</span>\n<span class=\"token string\">- The normal ones:</span>\n<span class=\"token string\">    ADD, SUB, EQL, LOAD_ARRAY ...</span>\n<span class=\"token string\">- The ones lead to jumping:</span>\n<span class=\"token string\">    JUMP, JUMP_IF ...</span>\n<span class=\"token string\">- The ones lead to jumping between functions:</span>\n<span class=\"token string\">    CALL, RETURN</span>\n<span class=\"token string\">`</span>\n</code></pre></div>\n<p>Let's write a slightly more complex program as an example:</p>\n<div class=\"remark-highlight\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span><span class=\"token function\">addN</span><span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">,</span><span class=\"token number\">69</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token function\">mul</span><span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">,</span> <span class=\"token number\">69</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">addN</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">,</span> n <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n    total <span class=\"token operator\">:=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&#x3C;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n        total <span class=\"token operator\">+=</span> m\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> total\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">mul</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">,</span> n <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> m <span class=\"token operator\">*</span> n\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>Below is the generated code, the instructions are numbered to make it easier to refer to:</p>\n<div class=\"remark-highlight\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token string\">`</span>\n<span class=\"token string\">main:</span>\n<span class=\"token string\">1    DUPLICATE       |1 |-9 |... |... |...,</span>\n<span class=\"token string\">2    DUPLICATE       |2 |-10 |... |... |...,</span>\n<span class=\"token string\">3    LOAD_PKG        |3 |-11 |1 |... |...,</span>\n<span class=\"token string\">4    CALL            |3 |0 |... |FlagA |...,</span>\n<span class=\"token string\">5    DUPLICATE       |5 |-12 |... |... |...,</span>\n<span class=\"token string\">6    DUPLICATE       |6 |-13 |... |... |...,</span>\n<span class=\"token string\">7    LOAD_PKG        |7 |-14 |2 |... |...,</span>\n<span class=\"token string\">8    CALL            |7 |4 |... |FlagA |...,</span>\n<span class=\"token string\">9    EQL             |8 |0 |4 |Int |Int,</span>\n<span class=\"token string\">10   ASSERT          |... |8 |... |... |...,</span>\n<span class=\"token string\">11   RETURN          |... |... |... |FlagA |...,</span>\n<span class=\"token string\"></span>\n<span class=\"token string\">addN:</span>\n<span class=\"token string\">12   DUPLICATE       |3 |-7 |... |... |...,</span>\n<span class=\"token string\">13   DUPLICATE       |4 |-8 |... |... |...,</span>\n<span class=\"token string\">14   LSS             |5 |4 |2 |Int |...,</span>\n<span class=\"token string\">15   JUMP_IF_NOT     |3 |5 |... |... |...,</span>\n<span class=\"token string\">16   ADD_ASSIGN      |3 |1 |... |Int |...,</span>\n<span class=\"token string\">17   INC             |4 |... |... |Int |...,</span>\n<span class=\"token string\">18   JUMP            |-5 |... |... |... |...,</span>\n<span class=\"token string\">19   DUPLICATE       |0 |3 |... |... |...,</span>\n<span class=\"token string\">20   RETURN          |... |... |... |FlagA |...,</span>\n<span class=\"token string\"></span>\n<span class=\"token string\">mul:</span>\n<span class=\"token string\">21   MUL             |0 |1 |2 |Int |...,</span>\n<span class=\"token string\">22   RETURN          |... |... |... |FlagA |...,</span>\n<span class=\"token string\">`</span>\n</code></pre></div>\n<p>This is what happens when the VM execute the code:</p>\n<div class=\"remark-highlight\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token string\">`</span>\n<span class=\"token string\">1: Copy 42 to register1 as addN's argument</span>\n<span class=\"token string\">2: Copy 69 to register2 as addN's argument</span>\n<span class=\"token string\">3: Load \"addN\" to register3</span>\n<span class=\"token string\">4: Call \"addN\", jump to instructions in \"addN\"</span>\n<span class=\"token string\">12: Initialize \"total\" as 0</span>\n<span class=\"token string\">13: Initialize \"i\" as 0</span>\n<span class=\"token string\">14: Compare register4(\"i\") and register2(\"n\") to see if i &#x3C; n, and put the result in register5</span>\n<span class=\"token string\">15: If register5 is not TRUE, jump to 19</span>\n<span class=\"token string\">16: total += m</span>\n<span class=\"token string\">17: i++</span>\n<span class=\"token string\">18: Jump back to 14</span>\n<span class=\"token string\">14: ...</span>\n<span class=\"token string\">... ...</span>\n<span class=\"token string\">14: ...</span>\n<span class=\"token string\">15: Jump to 19</span>\n<span class=\"token string\">19: Copy register3(\"total\") to register0(return value)</span>\n<span class=\"token string\">20: return, jump back to \"main\"</span>\n<span class=\"token string\">5: Copy 42 to register5 as mul's argument</span>\n<span class=\"token string\">6: Copy 69 to register6 as mul's argument</span>\n<span class=\"token string\">7: Load \"mul\" to register7</span>\n<span class=\"token string\">8: Call \"mul\", jump to instructions in \"mul\"</span>\n<span class=\"token string\">22: register0(return value) = register1(argument1) * register2(argument2)</span>\n<span class=\"token string\">23: return, jump back to \"main\"</span>\n<span class=\"token string\">9:  Compare register0 and register4 to see if they are equal, and put the result in register8</span>\n<span class=\"token string\">10: crash if register8 != true</span>\n<span class=\"token string\">11: return, jump out of main and exit the program</span>\n<span class=\"token string\">`</span>\n</code></pre></div>\n<h3>Coming up next</h3>\n<p>So far, there is almost nothing specifically about Goscript, pretty much the same thing happens in Python, Lua or even Java, though there are a few differences: Python or Lua doesn't have a type checker, and Java has a much more complicated VM.</p>\n<p>The next article will be a deep-dive into Goscript's VM, to explain how various of Go features are implemented in a simple VM, which, unlike to other parts of the project, is a relatively original wheel that got invented.</p>\n","title":"Goscript Internals I: Overview ","date":"2022-07-04","translation":"goscript_internals_I_overview_zh","translation_lang":"中文"}},"__N_SSG":true}