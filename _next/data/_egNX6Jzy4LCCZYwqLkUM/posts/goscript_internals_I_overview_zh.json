{"pageProps":{"postData":{"id":"goscript_internals_I_overview_zh","contentHtml":"<h2>简介</h2>\n<p>Goscript是一个用Rust写的,基于虚拟机的Go语言标准实现。Goscript设计原理系列文章的目标是说明其工作机制。目标读者是任何有兴趣了解Goscipt如何工作的人，或者更宽泛地说，任何对编译器，脚本语言，或者Go语言可以如何实现有兴趣的人。具备编译器/Rust/Go相关的背景知识肯定会有助于理解，但不是必须的。同时，对于专家来说，很可能就不值一看了。</p>\n<p>开始之前，我们给各个子项目列个表：</p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>简介</th>\n<th>编程语言</th>\n<th>创作方</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Parser</td>\n<td>解析器，从源代码到AST</td>\n<td>Rust</td>\n<td>移植自官方Go版本</td>\n</tr>\n<tr>\n<td>Type Checker</td>\n<td>类型推导及其他</td>\n<td>Rust</td>\n<td>移植自官方Go版本</td>\n</tr>\n<tr>\n<td>Codegen</td>\n<td>从AST到字节码</td>\n<td>Rust</td>\n<td>原创</td>\n</tr>\n<tr>\n<td>VM</td>\n<td>虚拟机，运行字节码</td>\n<td>Rust</td>\n<td>原创</td>\n</tr>\n<tr>\n<td>Engine</td>\n<td>封装和标准库的native部分</td>\n<td>Rust</td>\n<td>原创</td>\n</tr>\n<tr>\n<td>Std</td>\n<td>标准库</td>\n<td>Go</td>\n<td>移植自官方</td>\n</tr>\n</tbody>\n</table>\n<p>我们先用一个简单的例子来展示，Goscript运行代码时发生了什么：</p>\n<div class=\"remark-highlight\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    b <span class=\"token operator\">:=</span> <span class=\"token number\">2</span>\n    c <span class=\"token operator\">:=</span> a <span class=\"token operator\">+</span> b\n    <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 内置函数</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<h3>解析器</h3>\n<p>解析器读取源代码然后把它变成一颗抽象语法树即AST (<a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">Abstract Syntax Tree</a>)</p>\n<ul>\n<li>手写的分词器 (<a href=\"https://github.com/oxfeeefeee/goscript/blob/master/parser/src/scanner.rs\">scanner.rs</a>) 把源代码变成一个token流，像这样:</li>\n</ul>\n<div class=\"remark-highlight\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token string\">`</span>\n<span class=\"token string\">package, main, var, a, EQL, 1, ...</span>\n<span class=\"token string\">`</span>\n</code></pre></div>\n<ul>\n<li>手写的 <a href=\"https://en.wikipedia.org/wiki/Recursive_descent_parser\">递归下降</a> 解析器 (<a href=\"https://github.com/oxfeeefeee/goscript/blob/master/parser/src/parser.rs\">parser.rs</a>) 将token流变成语法树. 这一步可能看起来有点黑魔法，但是实际上非常直白：它就是这样一个递归程序：通过匹配当前遇到的token和预期的token，来递归的生成各种代表语句或者表达式的节点。AST的定义在这里 (<a href=\"https://github.com/oxfeeefeee/goscript/blob/master/parser/src/ast.rs\">ast.rs</a>). 上面小程序的AST大概长这样:\n<img src=\"/images/ast.jpeg\" alt=\"ast\"></li>\n</ul>\n<h3>类型检查器</h3>\n<p>类型检查器的首要作用就是类型推导，就是说推算出每个变量，结构体，函数等的具体类型。这些类型信息会用作代码生成和语法错误的检查。具体原理是：遍历AST并根据语言标准定义的规则确定类型信息，同时检查类型不合法的情况。主要代码见 <a href=\"https://github.com/oxfeeefeee/goscript/blob/master/types/src/check/expr.rs\">expr.rs</a> 和 <a href=\"https://github.com/oxfeeefeee/goscript/blob/master/types/src/check/stmt.rs\">stmt.rs</a>。</p>\n<p>具体到我们的例子，它会推导出来 <code>a</code>, <code>b</code>, <code>a + b</code> 和 <code>c</code> 的类型都是 <code>int</code>； <code>c == 3</code> 的类型是 <code>bool</code>。同时它也会检查 <code>assert</code> 的确是接受并且仅接受一个  <code>bool</code> 类型的参数。</p>\n<p>类型检查是整个项目最复杂的一部分，有一个Go <a href=\"https://go.googlesource.com/example/+/HEAD/gotypes/go-types.md\">官方文档</a> 可供参考。 除了类型推导，它还会做 <a href=\"https://github.com/oxfeeefeee/goscript/blob/master/types/src/check/resolver.rs\">ID 解析</a>, <a href=\"https://github.com/oxfeeefeee/goscript/blob/master/types/src/constant.rs\">常量计算</a>, 和 <a href=\"https://github.com/oxfeeefeee/goscript/blob/master/types/src/check/initorder.rs\">初始化顺序计算</a>.</p>\n<p>类型检查的输出结果是一个没有任何语法错误的AST，和AST的类型信息库，这些会被用于代码生成。</p>\n<h3>代码生成器</h3>\n<p>代码生成器通过再次遍历AST生成运行时对象，其中包含字节码。上面例子相应生产的代码大概如下:</p>\n<div class=\"remark-highlight\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token string\">`</span>\n<span class=\"token string\">- Package Object (main)</span>\n<span class=\"token string\">    - Package member variable (a)</span>\n<span class=\"token string\">    - Package member function (constructor)</span>\n<span class=\"token string\">        - bytecode: </span>\n<span class=\"token string\">            // copy constant10 to register0, which is where \"a\" is</span>\n<span class=\"token string\">            DUPLICATE   |0  |-10 </span>\n<span class=\"token string\">            RETURN          </span>\n<span class=\"token string\">    - Package member variable (main)</span>\n<span class=\"token string\">        - bytecode:</span>\n<span class=\"token string\">            // copy constant7 to register0, which is where \"b\" is</span>\n<span class=\"token string\">            DUPLICATE       |0  |-7 </span>\n<span class=\"token string\">            // load from package8's 0th member, which is \"a\", to register2 </span>\n<span class=\"token string\">            LOAD_PKG        |2  |-8 |0</span>\n<span class=\"token string\">            // register1 = register2 + register0</span>\n<span class=\"token string\">            ADD             |1  |2  |0</span>\n<span class=\"token string\">            // register2 = (register1 == constant9)</span>\n<span class=\"token string\">            EQL             |2  |1  |-9</span>\n<span class=\"token string\">            // crash if register2 != true</span>\n<span class=\"token string\">            ASSERT          |...|2  </span>\n<span class=\"token string\">            RETURN   </span>\n<span class=\"token string\">`</span>   \n</code></pre></div>\n<p>Goscript最初使用的是基于栈的虚拟机，现在已经改为基于寄存器的。栈虚拟机相对直观，更容易实现，但是寄存器虚拟机性能会更好。比如说上面那个<code>ADD</code>，在用栈虚拟机的时候还需要两个\"PUSH\"和一个\"POP\"一起才能完成。</p>\n<p>本质上来说，代码生成器是一个翻译器，它把一颗树翻译为一个一维数组。这样虚拟机自己就不用去遍历树了，虽然那样也可以做到。虚拟机现在只需要在一个虚拟的纸带上一个接一个处理指令，或者按照指令的要求跳转即可。代码生成的主要代码：<a href=\"https://github.com/oxfeeefeee/goscript/blob/master/codegen/src/codegen.rs\">codegen.rs</a>.</p>\n<h3>虚拟机</h3>\n<p>如上所述，虚拟机就是一个巨大的循环(<a href=\"https://github.com/oxfeeefeee/goscript/blob/master/vm/src/vm.rs\">vm.rs</a>)，它一个接一个处理指令知道结束，所有的指令大概可以分为三类。</p>\n<div class=\"remark-highlight\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token string\">`</span>\n<span class=\"token string\">- 普通指令:</span>\n<span class=\"token string\">    ADD, SUB, EQL, LOAD_ARRAY ...</span>\n<span class=\"token string\">- 跳转指令:</span>\n<span class=\"token string\">    JUMP, JUMP_IF ...</span>\n<span class=\"token string\">- 函数间跳转指令:</span>\n<span class=\"token string\">    CALL, RETURN</span>\n<span class=\"token string\">`</span>\n</code></pre></div>\n<p>我们再来看一个稍微复杂的例子:</p>\n<div class=\"remark-highlight\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span><span class=\"token function\">addN</span><span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">,</span><span class=\"token number\">69</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token function\">mul</span><span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">,</span> <span class=\"token number\">69</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">addN</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">,</span> n <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n total <span class=\"token operator\">:=</span> <span class=\"token number\">0</span>\n <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&#x3C;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n  total <span class=\"token operator\">+=</span> m\n <span class=\"token punctuation\">}</span>\n <span class=\"token keyword\">return</span> total\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">mul</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">,</span> n <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">return</span> m <span class=\"token operator\">*</span> n\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>下面是生成的代码，增加了标号以方便下文引用：</p>\n<div class=\"remark-highlight\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token string\">`</span>\n<span class=\"token string\">main:</span>\n<span class=\"token string\">1    DUPLICATE       |1 |-9 |... |... |...,</span>\n<span class=\"token string\">2    DUPLICATE       |2 |-10 |... |... |...,</span>\n<span class=\"token string\">3    LOAD_PKG        |3 |-11 |1 |... |...,</span>\n<span class=\"token string\">4    CALL            |3 |0 |... |FlagA |...,</span>\n<span class=\"token string\">5    DUPLICATE       |5 |-12 |... |... |...,</span>\n<span class=\"token string\">6    DUPLICATE       |6 |-13 |... |... |...,</span>\n<span class=\"token string\">7    LOAD_PKG        |7 |-14 |2 |... |...,</span>\n<span class=\"token string\">8    CALL            |7 |4 |... |FlagA |...,</span>\n<span class=\"token string\">9    EQL             |8 |0 |4 |Int |Int,</span>\n<span class=\"token string\">10   ASSERT          |... |8 |... |... |...,</span>\n<span class=\"token string\">11   RETURN          |... |... |... |FlagA |...,</span>\n<span class=\"token string\"></span>\n<span class=\"token string\">addN:</span>\n<span class=\"token string\">12   DUPLICATE       |3 |-7 |... |... |...,</span>\n<span class=\"token string\">13   DUPLICATE       |4 |-8 |... |... |...,</span>\n<span class=\"token string\">14   LSS             |5 |4 |2 |Int |...,</span>\n<span class=\"token string\">15   JUMP_IF_NOT     |3 |5 |... |... |...,</span>\n<span class=\"token string\">16   ADD_ASSIGN      |3 |1 |... |Int |...,</span>\n<span class=\"token string\">17   INC             |4 |... |... |Int |...,</span>\n<span class=\"token string\">18   JUMP            |-5 |... |... |... |...,</span>\n<span class=\"token string\">19   DUPLICATE       |0 |3 |... |... |...,</span>\n<span class=\"token string\">20   RETURN          |... |... |... |FlagA |...,</span>\n<span class=\"token string\"></span>\n<span class=\"token string\">mul:</span>\n<span class=\"token string\">21   MUL             |0 |1 |2 |Int |...,</span>\n<span class=\"token string\">22   RETURN          |... |... |... |FlagA |...,</span>\n<span class=\"token string\">`</span>\n</code></pre></div>\n<p>这是在虚拟机中的执行过程:</p>\n<div class=\"remark-highlight\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token string\">`</span>\n<span class=\"token string\">1: 拷贝 42 到 register1 作为 addN 的 参数</span>\n<span class=\"token string\">2: 拷贝 69 到 register2 作为 addN 的 参数</span>\n<span class=\"token string\">3: 读取函数 \"addN\" 到 register3</span>\n<span class=\"token string\">4: 调用 \"addN\", 跳转到 \"addN\" 的第一个指令</span>\n<span class=\"token string\">12: 初始化 \"total\" 为 0</span>\n<span class=\"token string\">13: 初始化 \"i\" 为 0</span>\n<span class=\"token string\">14: 比较 register4(\"i\") 和 register2(\"n\") 看是否 i &#x3C; n, 把结果放到 register5</span>\n<span class=\"token string\">15: 如果 register5 不是 TRUE, 跳转到 19</span>\n<span class=\"token string\">16: total += m</span>\n<span class=\"token string\">17: i++</span>\n<span class=\"token string\">18: 跳转回 14</span>\n<span class=\"token string\">14: ...</span>\n<span class=\"token string\">... ...</span>\n<span class=\"token string\">14: ...</span>\n<span class=\"token string\">15: 跳转到 19</span>\n<span class=\"token string\">19: 拷贝 register3(\"total\") 到 register0(返回值)</span>\n<span class=\"token string\">20: 返回, 跳转回 \"main\"</span>\n<span class=\"token string\">5: 拷贝 42 到 register1 作为 mul 的 参数</span>\n<span class=\"token string\">6: 拷贝 69 到 register2 作为 mul 的 参数</span>\n<span class=\"token string\">7: 读取函数 \"mul\" 到 register7</span>\n<span class=\"token string\">8: 调用 \"mul\", 跳转到 \"mul\" 的第一个指令</span>\n<span class=\"token string\">22: register0(return value) = register1(argument1) * register2(argument2)</span>\n<span class=\"token string\">23: 返回, 跳转回 \"main\"</span>\n<span class=\"token string\">9:  比较 register0 和 register4 是否相等, 把结果放到 register8</span>\n<span class=\"token string\">10: 如果 register8 != true 就 crash</span>\n<span class=\"token string\">11: 返回, 跳转出main函数，结束执行</span>\n<span class=\"token string\">`</span>\n</code></pre></div>\n<h3>后续内容</h3>\n<p>目前为止，几乎没有讨论Goscript独有的机制，在Python, Lua 甚至 Java 里，大致的过程也是差不多的。当然有一些小的区别：Python 和 Lua 没有类型检查，而Java的虚拟机则要复杂很多。</p>\n<p>下一篇文章讲深入Goscript虚拟机内部，解释Go的各种特性是如何在一个相对简单的虚拟机里实现的，而这可能是一个相对有些新意的轮子。</p>\n","title":"Goscript 设计原理一: 总览","date":"2022-07-05","translation":"goscript_internals_I_overview_en","translation_lang":"English"}},"__N_SSG":true}