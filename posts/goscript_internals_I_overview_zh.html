<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><meta name="description" content="Goscript offical website"/><meta property="og:image" content="https://og-image.vercel.app/Goscript%20offical%20website.png?theme=light&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="og:title" content="Goscript offical website"/><meta name="twitter:card" content="summary_large_image"/><title>Goscript 设计原理一: 总览</title><meta name="next-head-count" content="8"/><link rel="preload" href="/_next/static/css/96f76011eaa949d6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/96f76011eaa949d6.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e07893e80d526a25.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e07893e80d526a25.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-c85490a6f758d8f5.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-ea86427ef25bef6d.js" defer=""></script><script src="/_next/static/chunks/pages/_app-20c4a81707b11a34.js" defer=""></script><script src="/_next/static/chunks/733-05d542b0b5535850.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-0f90271f7a4d1f3f.js" defer=""></script><script src="/_next/static/n8qca7tfeduTvWxVWQ9cn/_buildManifest.js" defer=""></script><script src="/_next/static/n8qca7tfeduTvWxVWQ9cn/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="layout_container__fbLkO"><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container"><a href="/" class="navbar-brand"> <img src="/images/goscript-logo.jpeg" width="45" height="45" class="utils_borderCircle__s2nTm" alt="goscript logo"/></a><button aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="basic-navbar-nav"><div class="me-auto navbar-nav"><a href="/" data-rr-ui-event-key="/" class="nav-link">Home</a><a href="/#blog-section" data-rr-ui-event-key="/#blog-section" class="nav-link">Blog</a><a href="https://github.com/oxfeeefeee/goscript" data-rr-ui-event-key="https://github.com/oxfeeefeee/goscript" class="nav-link">Github</a></div></div></div></nav><main><article><h1 class="utils_headingXl__u25Y2">Goscript 设计原理一: 总览</h1><div class="utils_lightText__eUzGY"><a href="https://github.com/oxfeeefeee/">oxfeeefeee</a> <a>2022-07-04</a> //<a href="/posts/goscript_internals_I_overview_en">English</a></div><div><h2>简介</h2>
<p>Goscript是一个用Rust写的,基于虚拟机的Go语言标准实现。Goscript设计原理系列文章的目标是说明其工作机制。目标读者是任何有兴趣了解Goscipt如何工作的人，或者更宽泛地说，任何对编译器，脚本语言，或者Go语言可以如何实现有兴趣的人。具备编译器/Rust/Go相关的背景知识肯定会有助于理解，但不是必须的。同时，对于专家来说，很可能就不值一看了。</p>
<p>开始之前，我们给各个子项目列个表：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>简介</th>
<th>编程语言</th>
<th>创作方</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parser</td>
<td>解析器，从源代码到AST</td>
<td>Rust</td>
<td>移植自官方Go版本</td>
</tr>
<tr>
<td>Type Checker</td>
<td>类型推导及其他</td>
<td>Rust</td>
<td>移植自官方Go版本</td>
</tr>
<tr>
<td>Codegen</td>
<td>从AST到字节码</td>
<td>Rust</td>
<td>原创</td>
</tr>
<tr>
<td>VM</td>
<td>虚拟机，运行字节码</td>
<td>Rust</td>
<td>原创</td>
</tr>
<tr>
<td>Engine</td>
<td>封装和标准库的native部分</td>
<td>Rust</td>
<td>原创</td>
</tr>
<tr>
<td>Std</td>
<td>标准库</td>
<td>Go</td>
<td>移植自官方</td>
</tr>
</tbody>
</table>
<p>我们先用一个简单的例子来展示，Goscript运行代码时发生了什么：</p>
<div class="remark-highlight"><pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    b <span class="token operator">:=</span> <span class="token number">2</span>
    c <span class="token operator">:=</span> a <span class="token operator">+</span> b
    <span class="token function">assert</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">// 内置函数</span>
<span class="token punctuation">}</span>
</code></pre></div>
<h3>解析器</h3>
<p>解析器读取源代码然后把它变成一颗抽象语法树即AST (<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a>)</p>
<ul>
<li>手写的分词器 (<a href="https://github.com/oxfeeefeee/goscript/blob/master/parser/src/scanner.rs">scanner.rs</a>) 把源代码变成一个token流，像这样:</li>
</ul>
<div class="remark-highlight"><pre class="language-go"><code class="language-go"><span class="token string">`</span>
<span class="token string">package, main, var, a, EQL, 1, ...</span>
<span class="token string">`</span>
</code></pre></div>
<ul>
<li>手写的 <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">递归下降</a> 解析器 (<a href="https://github.com/oxfeeefeee/goscript/blob/master/parser/src/parser.rs">parser.rs</a>) 将token流变成语法树. 这一步可能看起来有点黑魔法，但是实际上非常直白：它就是这样一个递归程序：通过匹配当前遇到的token和预期的token，来递归的生成各种代表语句或者表达式的节点。AST的定义在这里 (<a href="https://github.com/oxfeeefeee/goscript/blob/master/parser/src/ast.rs">ast.rs</a>). 上面小程序的AST大概长这样:
<img src="/images/ast.jpeg" alt="ast"></li>
</ul>
<h3>类型检查器</h3>
<p>类型检查器的首要作用就是类型推导，就是说推算出每个变量，结构体，函数等的具体类型。这些类型信息会用作代码生成和语法错误的检查。具体原理是：遍历AST并根据语言标准定义的规则确定类型信息，同时检查类型不合法的情况。主要代码见 <a href="https://github.com/oxfeeefeee/goscript/blob/master/types/src/check/expr.rs">expr.rs</a> 和 <a href="https://github.com/oxfeeefeee/goscript/blob/master/types/src/check/stmt.rs">stmt.rs</a>。</p>
<p>具体到我们的例子，它会推导出来 <code>a</code>, <code>b</code>, <code>a + b</code> 和 <code>c</code> 的类型都是 <code>int</code>； <code>c == 3</code> 的类型是 <code>bool</code>。同时它也会检查 <code>assert</code> 的确是接受并且仅接受一个  <code>bool</code> 类型的参数。</p>
<p>类型检查是整个项目最复杂的一部分，有一个Go <a href="https://go.googlesource.com/example/+/HEAD/gotypes/go-types.md">官方文档</a> 可供参考。 除了类型推导，它还会做 <a href="https://github.com/oxfeeefeee/goscript/blob/master/types/src/check/resolver.rs">ID 解析</a>, <a href="https://github.com/oxfeeefeee/goscript/blob/master/types/src/constant.rs">常量计算</a>, 和 <a href="https://github.com/oxfeeefeee/goscript/blob/master/types/src/check/initorder.rs">初始化顺序计算</a>.</p>
<p>类型检查的输出结果是一个没有任何语法错误的AST，和AST的类型信息库，这些会被用于代码生成。</p>
<h3>代码生成器</h3>
<p>代码生成器通过再次遍历AST生成运行时对象，其中包含字节码。上面例子相应生产的代码大概如下:</p>
<div class="remark-highlight"><pre class="language-go"><code class="language-go"><span class="token string">`</span>
<span class="token string">- Package Object (main)</span>
<span class="token string">    - Package member variable (a)</span>
<span class="token string">    - Package member function (constructor)</span>
<span class="token string">        - bytecode: </span>
<span class="token string">            // copy constant10 to register0, which is where "a" is</span>
<span class="token string">            DUPLICATE   |0  |-10 </span>
<span class="token string">            RETURN          </span>
<span class="token string">    - Package member variable (main)</span>
<span class="token string">        - bytecode:</span>
<span class="token string">            // copy constant7 to register0, which is where "b" is</span>
<span class="token string">            DUPLICATE       |0  |-7 </span>
<span class="token string">            // load from package8's 0th member, which is "a", to register2 </span>
<span class="token string">            LOAD_PKG        |2  |-8 |0</span>
<span class="token string">            // register1 = register2 + register0</span>
<span class="token string">            ADD             |1  |2  |0</span>
<span class="token string">            // register2 = (register1 == constant9)</span>
<span class="token string">            EQL             |2  |1  |-9</span>
<span class="token string">            // crash if register2 != true</span>
<span class="token string">            ASSERT          |...|2  </span>
<span class="token string">            RETURN   </span>
<span class="token string">`</span>   
</code></pre></div>
<p>Goscript最初使用的是基于栈的虚拟机，现在已经改为基于寄存器的。栈虚拟机相对直观，更容易实现，但是寄存器虚拟机性能会更好。比如说上面那个<code>ADD</code>，在用栈虚拟机的时候还需要两个"PUSH"和一个"POP"一起才能完成。</p>
<p>本质上来说，代码生成器是一个翻译器，它把一颗树翻译为一个一维数组。这样虚拟机自己就不用去遍历树了，虽然那样也可以做到。虚拟机现在只需要在一个虚拟的纸带上一个接一个处理指令，或者按照指令的要求跳转即可。代码生成的主要代码：<a href="https://github.com/oxfeeefeee/goscript/blob/master/codegen/src/codegen.rs">codegen.rs</a>.</p>
<h3>虚拟机</h3>
<p>如上所述，虚拟机就是一个巨大的循环(<a href="https://github.com/oxfeeefeee/goscript/blob/master/vm/src/vm.rs">vm.rs</a>)，它一个接一个处理指令知道结束，所有的指令大概可以分为三类。</p>
<div class="remark-highlight"><pre class="language-go"><code class="language-go"><span class="token string">`</span>
<span class="token string">- 普通指令:</span>
<span class="token string">    ADD, SUB, EQL, LOAD_ARRAY ...</span>
<span class="token string">- 跳转指令:</span>
<span class="token string">    JUMP, JUMP_IF ...</span>
<span class="token string">- 函数间跳转指令:</span>
<span class="token string">    CALL, RETURN</span>
<span class="token string">`</span>
</code></pre></div>
<p>我们再来看一个稍微复杂的例子:</p>
<div class="remark-highlight"><pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">addN</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span><span class="token number">69</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">69</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">addN</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
 total <span class="token operator">:=</span> <span class="token number">0</span>
 <span class="token keyword">for</span> i <span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
  total <span class="token operator">+=</span> m
 <span class="token punctuation">}</span>
 <span class="token keyword">return</span> total
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">mul</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> m <span class="token operator">*</span> n
<span class="token punctuation">}</span>
</code></pre></div>
<p>下面是生成的代码，增加了标号以方便下文引用：</p>
<div class="remark-highlight"><pre class="language-go"><code class="language-go"><span class="token string">`</span>
<span class="token string">main:</span>
<span class="token string">1    DUPLICATE       |1 |-9 |... |... |...,</span>
<span class="token string">2    DUPLICATE       |2 |-10 |... |... |...,</span>
<span class="token string">3    LOAD_PKG        |3 |-11 |1 |... |...,</span>
<span class="token string">4    CALL            |3 |0 |... |FlagA |...,</span>
<span class="token string">5    DUPLICATE       |5 |-12 |... |... |...,</span>
<span class="token string">6    DUPLICATE       |6 |-13 |... |... |...,</span>
<span class="token string">7    LOAD_PKG        |7 |-14 |2 |... |...,</span>
<span class="token string">8    CALL            |7 |4 |... |FlagA |...,</span>
<span class="token string">9    EQL             |8 |0 |4 |Int |Int,</span>
<span class="token string">10   ASSERT          |... |8 |... |... |...,</span>
<span class="token string">11   RETURN          |... |... |... |FlagA |...,</span>
<span class="token string"></span>
<span class="token string">addN:</span>
<span class="token string">12   DUPLICATE       |3 |-7 |... |... |...,</span>
<span class="token string">13   DUPLICATE       |4 |-8 |... |... |...,</span>
<span class="token string">14   LSS             |5 |4 |2 |Int |...,</span>
<span class="token string">15   JUMP_IF_NOT     |3 |5 |... |... |...,</span>
<span class="token string">16   ADD_ASSIGN      |3 |1 |... |Int |...,</span>
<span class="token string">17   INC             |4 |... |... |Int |...,</span>
<span class="token string">18   JUMP            |-5 |... |... |... |...,</span>
<span class="token string">19   DUPLICATE       |0 |3 |... |... |...,</span>
<span class="token string">20   RETURN          |... |... |... |FlagA |...,</span>
<span class="token string"></span>
<span class="token string">mul:</span>
<span class="token string">21   MUL             |0 |1 |2 |Int |...,</span>
<span class="token string">22   RETURN          |... |... |... |FlagA |...,</span>
<span class="token string">`</span>
</code></pre></div>
<p>这是在虚拟机中的执行过程:</p>
<div class="remark-highlight"><pre class="language-go"><code class="language-go"><span class="token string">`</span>
<span class="token string">1: 拷贝 42 到 register1 作为 addN 的 参数</span>
<span class="token string">2: 拷贝 69 到 register2 作为 addN 的 参数</span>
<span class="token string">3: 读取函数 "addN" 到 register3</span>
<span class="token string">4: 调用 "addN", 跳转到 "addN" 的第一个指令</span>
<span class="token string">12: 初始化 "total" 为 0</span>
<span class="token string">13: 初始化 "i" 为 0</span>
<span class="token string">14: 比较 register4("i") 和 register2("n") 看是否 i &#x3C; n, 把结果放到 register5</span>
<span class="token string">15: 如果 register5 不是 TRUE, 跳转到 19</span>
<span class="token string">16: total += m</span>
<span class="token string">17: i++</span>
<span class="token string">18: 跳转回 14</span>
<span class="token string">14: ...</span>
<span class="token string">... ...</span>
<span class="token string">14: ...</span>
<span class="token string">15: 跳转到 19</span>
<span class="token string">19: 拷贝 register3("total") 到 register0(返回值)</span>
<span class="token string">20: 返回, 跳转回 "main"</span>
<span class="token string">5: 拷贝 42 到 register1 作为 mul 的 参数</span>
<span class="token string">6: 拷贝 69 到 register2 作为 mul 的 参数</span>
<span class="token string">7: 读取函数 "mul" 到 register7</span>
<span class="token string">8: 调用 "mul", 跳转到 "mul" 的第一个指令</span>
<span class="token string">22: register0(return value) = register1(argument1) * register2(argument2)</span>
<span class="token string">23: 返回, 跳转回 "main"</span>
<span class="token string">9:  比较 register0 和 register4 是否相等, 把结果放到 register8</span>
<span class="token string">10: 如果 register8 != true 就 crash</span>
<span class="token string">11: 返回, 跳转出main函数，结束执行</span>
<span class="token string">`</span>
</code></pre></div>
<h3>后续内容</h3>
<p>目前为止，几乎没有讨论Goscript独有的机制，在Python, Lua 甚至 Java 里，大致的过程也是差不多的。当然有一些小的区别：Python 和 Lua 没有类型检查，而Java的虚拟机则要复杂很多。</p>
<p>下一篇文章讲深入Goscript虚拟机内部，解释Go的各种特性是如何在一个相对简单的虚拟机里实现的，而这可能是一个相对有些新意的轮子。</p>
</div></article></main><div class="layout_backToHome__9sjx_"><a href="/">← Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"goscript_internals_I_overview_zh","contentHtml":"\u003ch2\u003e简介\u003c/h2\u003e\n\u003cp\u003eGoscript是一个用Rust写的,基于虚拟机的Go语言标准实现。Goscript设计原理系列文章的目标是说明其工作机制。目标读者是任何有兴趣了解Goscipt如何工作的人，或者更宽泛地说，任何对编译器，脚本语言，或者Go语言可以如何实现有兴趣的人。具备编译器/Rust/Go相关的背景知识肯定会有助于理解，但不是必须的。同时，对于专家来说，很可能就不值一看了。\u003c/p\u003e\n\u003cp\u003e开始之前，我们给各个子项目列个表：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e项目\u003c/th\u003e\n\u003cth\u003e简介\u003c/th\u003e\n\u003cth\u003e编程语言\u003c/th\u003e\n\u003cth\u003e创作方\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eParser\u003c/td\u003e\n\u003ctd\u003e解析器，从源代码到AST\u003c/td\u003e\n\u003ctd\u003eRust\u003c/td\u003e\n\u003ctd\u003e移植自官方Go版本\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eType Checker\u003c/td\u003e\n\u003ctd\u003e类型推导及其他\u003c/td\u003e\n\u003ctd\u003eRust\u003c/td\u003e\n\u003ctd\u003e移植自官方Go版本\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eCodegen\u003c/td\u003e\n\u003ctd\u003e从AST到字节码\u003c/td\u003e\n\u003ctd\u003eRust\u003c/td\u003e\n\u003ctd\u003e原创\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eVM\u003c/td\u003e\n\u003ctd\u003e虚拟机，运行字节码\u003c/td\u003e\n\u003ctd\u003eRust\u003c/td\u003e\n\u003ctd\u003e原创\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eEngine\u003c/td\u003e\n\u003ctd\u003e封装和标准库的native部分\u003c/td\u003e\n\u003ctd\u003eRust\u003c/td\u003e\n\u003ctd\u003e原创\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eStd\u003c/td\u003e\n\u003ctd\u003e标准库\u003c/td\u003e\n\u003ctd\u003eGo\u003c/td\u003e\n\u003ctd\u003e移植自官方\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e我们先用一个简单的例子来展示，Goscript运行代码时发生了什么：\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-go\"\u003e\u003ccode class=\"language-go\"\u003e\u003cspan class=\"token keyword\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"token keyword\"\u003evar\u003c/span\u003e a \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e1\u003c/span\u003e\n\n\u003cspan class=\"token keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"token function\"\u003emain\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    b \u003cspan class=\"token operator\"\u003e:=\u003c/span\u003e \u003cspan class=\"token number\"\u003e2\u003c/span\u003e\n    c \u003cspan class=\"token operator\"\u003e:=\u003c/span\u003e a \u003cspan class=\"token operator\"\u003e+\u003c/span\u003e b\n    \u003cspan class=\"token function\"\u003eassert\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ec \u003cspan class=\"token operator\"\u003e==\u003c/span\u003e \u003cspan class=\"token number\"\u003e3\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token comment\"\u003e// 内置函数\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch3\u003e解析器\u003c/h3\u003e\n\u003cp\u003e解析器读取源代码然后把它变成一颗抽象语法树即AST (\u003ca href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\"\u003eAbstract Syntax Tree\u003c/a\u003e)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e手写的分词器 (\u003ca href=\"https://github.com/oxfeeefeee/goscript/blob/master/parser/src/scanner.rs\"\u003escanner.rs\u003c/a\u003e) 把源代码变成一个token流，像这样:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-go\"\u003e\u003ccode class=\"language-go\"\u003e\u003cspan class=\"token string\"\u003e`\u003c/span\u003e\n\u003cspan class=\"token string\"\u003epackage, main, var, a, EQL, 1, ...\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e`\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e手写的 \u003ca href=\"https://en.wikipedia.org/wiki/Recursive_descent_parser\"\u003e递归下降\u003c/a\u003e 解析器 (\u003ca href=\"https://github.com/oxfeeefeee/goscript/blob/master/parser/src/parser.rs\"\u003eparser.rs\u003c/a\u003e) 将token流变成语法树. 这一步可能看起来有点黑魔法，但是实际上非常直白：它就是这样一个递归程序：通过匹配当前遇到的token和预期的token，来递归的生成各种代表语句或者表达式的节点。AST的定义在这里 (\u003ca href=\"https://github.com/oxfeeefeee/goscript/blob/master/parser/src/ast.rs\"\u003east.rs\u003c/a\u003e). 上面小程序的AST大概长这样:\n\u003cimg src=\"/images/ast.jpeg\" alt=\"ast\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e类型检查器\u003c/h3\u003e\n\u003cp\u003e类型检查器的首要作用就是类型推导，就是说推算出每个变量，结构体，函数等的具体类型。这些类型信息会用作代码生成和语法错误的检查。具体原理是：遍历AST并根据语言标准定义的规则确定类型信息，同时检查类型不合法的情况。主要代码见 \u003ca href=\"https://github.com/oxfeeefeee/goscript/blob/master/types/src/check/expr.rs\"\u003eexpr.rs\u003c/a\u003e 和 \u003ca href=\"https://github.com/oxfeeefeee/goscript/blob/master/types/src/check/stmt.rs\"\u003estmt.rs\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e具体到我们的例子，它会推导出来 \u003ccode\u003ea\u003c/code\u003e, \u003ccode\u003eb\u003c/code\u003e, \u003ccode\u003ea + b\u003c/code\u003e 和 \u003ccode\u003ec\u003c/code\u003e 的类型都是 \u003ccode\u003eint\u003c/code\u003e； \u003ccode\u003ec == 3\u003c/code\u003e 的类型是 \u003ccode\u003ebool\u003c/code\u003e。同时它也会检查 \u003ccode\u003eassert\u003c/code\u003e 的确是接受并且仅接受一个  \u003ccode\u003ebool\u003c/code\u003e 类型的参数。\u003c/p\u003e\n\u003cp\u003e类型检查是整个项目最复杂的一部分，有一个Go \u003ca href=\"https://go.googlesource.com/example/+/HEAD/gotypes/go-types.md\"\u003e官方文档\u003c/a\u003e 可供参考。 除了类型推导，它还会做 \u003ca href=\"https://github.com/oxfeeefeee/goscript/blob/master/types/src/check/resolver.rs\"\u003eID 解析\u003c/a\u003e, \u003ca href=\"https://github.com/oxfeeefeee/goscript/blob/master/types/src/constant.rs\"\u003e常量计算\u003c/a\u003e, 和 \u003ca href=\"https://github.com/oxfeeefeee/goscript/blob/master/types/src/check/initorder.rs\"\u003e初始化顺序计算\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e类型检查的输出结果是一个没有任何语法错误的AST，和AST的类型信息库，这些会被用于代码生成。\u003c/p\u003e\n\u003ch3\u003e代码生成器\u003c/h3\u003e\n\u003cp\u003e代码生成器通过再次遍历AST生成运行时对象，其中包含字节码。上面例子相应生产的代码大概如下:\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-go\"\u003e\u003ccode class=\"language-go\"\u003e\u003cspan class=\"token string\"\u003e`\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e- Package Object (main)\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e    - Package member variable (a)\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e    - Package member function (constructor)\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e        - bytecode: \u003c/span\u003e\n\u003cspan class=\"token string\"\u003e            // copy constant10 to register0, which is where \"a\" is\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e            DUPLICATE   |0  |-10 \u003c/span\u003e\n\u003cspan class=\"token string\"\u003e            RETURN          \u003c/span\u003e\n\u003cspan class=\"token string\"\u003e    - Package member variable (main)\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e        - bytecode:\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e            // copy constant7 to register0, which is where \"b\" is\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e            DUPLICATE       |0  |-7 \u003c/span\u003e\n\u003cspan class=\"token string\"\u003e            // load from package8's 0th member, which is \"a\", to register2 \u003c/span\u003e\n\u003cspan class=\"token string\"\u003e            LOAD_PKG        |2  |-8 |0\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e            // register1 = register2 + register0\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e            ADD             |1  |2  |0\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e            // register2 = (register1 == constant9)\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e            EQL             |2  |1  |-9\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e            // crash if register2 != true\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e            ASSERT          |...|2  \u003c/span\u003e\n\u003cspan class=\"token string\"\u003e            RETURN   \u003c/span\u003e\n\u003cspan class=\"token string\"\u003e`\u003c/span\u003e   \n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eGoscript最初使用的是基于栈的虚拟机，现在已经改为基于寄存器的。栈虚拟机相对直观，更容易实现，但是寄存器虚拟机性能会更好。比如说上面那个\u003ccode\u003eADD\u003c/code\u003e，在用栈虚拟机的时候还需要两个\"PUSH\"和一个\"POP\"一起才能完成。\u003c/p\u003e\n\u003cp\u003e本质上来说，代码生成器是一个翻译器，它把一颗树翻译为一个一维数组。这样虚拟机自己就不用去遍历树了，虽然那样也可以做到。虚拟机现在只需要在一个虚拟的纸带上一个接一个处理指令，或者按照指令的要求跳转即可。代码生成的主要代码：\u003ca href=\"https://github.com/oxfeeefeee/goscript/blob/master/codegen/src/codegen.rs\"\u003ecodegen.rs\u003c/a\u003e.\u003c/p\u003e\n\u003ch3\u003e虚拟机\u003c/h3\u003e\n\u003cp\u003e如上所述，虚拟机就是一个巨大的循环(\u003ca href=\"https://github.com/oxfeeefeee/goscript/blob/master/vm/src/vm.rs\"\u003evm.rs\u003c/a\u003e)，它一个接一个处理指令知道结束，所有的指令大概可以分为三类。\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-go\"\u003e\u003ccode class=\"language-go\"\u003e\u003cspan class=\"token string\"\u003e`\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e- 普通指令:\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e    ADD, SUB, EQL, LOAD_ARRAY ...\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e- 跳转指令:\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e    JUMP, JUMP_IF ...\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e- 函数间跳转指令:\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e    CALL, RETURN\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e`\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e我们再来看一个稍微复杂的例子:\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-go\"\u003e\u003ccode class=\"language-go\"\u003e\u003cspan class=\"token keyword\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"token keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"token function\"\u003emain\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n \u003cspan class=\"token function\"\u003eassert\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token function\"\u003eaddN\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token number\"\u003e42\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\u003cspan class=\"token number\"\u003e69\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e==\u003c/span\u003e \u003cspan class=\"token function\"\u003emul\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token number\"\u003e42\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e69\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"token keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"token function\"\u003eaddN\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003em\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e n \u003cspan class=\"token builtin\"\u003eint\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eint\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n total \u003cspan class=\"token operator\"\u003e:=\u003c/span\u003e \u003cspan class=\"token number\"\u003e0\u003c/span\u003e\n \u003cspan class=\"token keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"token operator\"\u003e:=\u003c/span\u003e\u003cspan class=\"token number\"\u003e0\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e i \u003cspan class=\"token operator\"\u003e\u0026#x3C;\u003c/span\u003e n\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e i\u003cspan class=\"token operator\"\u003e++\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  total \u003cspan class=\"token operator\"\u003e+=\u003c/span\u003e m\n \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e total\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"token keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"token function\"\u003emul\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003em\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e n \u003cspan class=\"token builtin\"\u003eint\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eint\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e m \u003cspan class=\"token operator\"\u003e*\u003c/span\u003e n\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e下面是生成的代码，增加了标号以方便下文引用：\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-go\"\u003e\u003ccode class=\"language-go\"\u003e\u003cspan class=\"token string\"\u003e`\u003c/span\u003e\n\u003cspan class=\"token string\"\u003emain:\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e1    DUPLICATE       |1 |-9 |... |... |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e2    DUPLICATE       |2 |-10 |... |... |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e3    LOAD_PKG        |3 |-11 |1 |... |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e4    CALL            |3 |0 |... |FlagA |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e5    DUPLICATE       |5 |-12 |... |... |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e6    DUPLICATE       |6 |-13 |... |... |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e7    LOAD_PKG        |7 |-14 |2 |... |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e8    CALL            |7 |4 |... |FlagA |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e9    EQL             |8 |0 |4 |Int |Int,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e10   ASSERT          |... |8 |... |... |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e11   RETURN          |... |... |... |FlagA |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e\u003c/span\u003e\n\u003cspan class=\"token string\"\u003eaddN:\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e12   DUPLICATE       |3 |-7 |... |... |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e13   DUPLICATE       |4 |-8 |... |... |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e14   LSS             |5 |4 |2 |Int |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e15   JUMP_IF_NOT     |3 |5 |... |... |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e16   ADD_ASSIGN      |3 |1 |... |Int |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e17   INC             |4 |... |... |Int |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e18   JUMP            |-5 |... |... |... |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e19   DUPLICATE       |0 |3 |... |... |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e20   RETURN          |... |... |... |FlagA |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e\u003c/span\u003e\n\u003cspan class=\"token string\"\u003emul:\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e21   MUL             |0 |1 |2 |Int |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e22   RETURN          |... |... |... |FlagA |...,\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e`\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e这是在虚拟机中的执行过程:\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-go\"\u003e\u003ccode class=\"language-go\"\u003e\u003cspan class=\"token string\"\u003e`\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e1: 拷贝 42 到 register1 作为 addN 的 参数\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e2: 拷贝 69 到 register2 作为 addN 的 参数\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e3: 读取函数 \"addN\" 到 register3\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e4: 调用 \"addN\", 跳转到 \"addN\" 的第一个指令\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e12: 初始化 \"total\" 为 0\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e13: 初始化 \"i\" 为 0\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e14: 比较 register4(\"i\") 和 register2(\"n\") 看是否 i \u0026#x3C; n, 把结果放到 register5\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e15: 如果 register5 不是 TRUE, 跳转到 19\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e16: total += m\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e17: i++\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e18: 跳转回 14\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e14: ...\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e... ...\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e14: ...\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e15: 跳转到 19\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e19: 拷贝 register3(\"total\") 到 register0(返回值)\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e20: 返回, 跳转回 \"main\"\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e5: 拷贝 42 到 register1 作为 mul 的 参数\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e6: 拷贝 69 到 register2 作为 mul 的 参数\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e7: 读取函数 \"mul\" 到 register7\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e8: 调用 \"mul\", 跳转到 \"mul\" 的第一个指令\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e22: register0(return value) = register1(argument1) * register2(argument2)\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e23: 返回, 跳转回 \"main\"\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e9:  比较 register0 和 register4 是否相等, 把结果放到 register8\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e10: 如果 register8 != true 就 crash\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e11: 返回, 跳转出main函数，结束执行\u003c/span\u003e\n\u003cspan class=\"token string\"\u003e`\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch3\u003e后续内容\u003c/h3\u003e\n\u003cp\u003e目前为止，几乎没有讨论Goscript独有的机制，在Python, Lua 甚至 Java 里，大致的过程也是差不多的。当然有一些小的区别：Python 和 Lua 没有类型检查，而Java的虚拟机则要复杂很多。\u003c/p\u003e\n\u003cp\u003e下一篇文章讲深入Goscript虚拟机内部，解释Go的各种特性是如何在一个相对简单的虚拟机里实现的，而这可能是一个相对有些新意的轮子。\u003c/p\u003e\n","title":"Goscript 设计原理一: 总览","date":"2022-07-04","translation":"goscript_internals_I_overview_en","translation_lang":"English"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"goscript_internals_I_overview_zh"},"buildId":"n8qca7tfeduTvWxVWQ9cn","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>