<!DOCTYPE html>
<html>

<head>
    <meta charSet="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="description" content="Goscript offical website" />
    <meta property="og:image"
        content="https://og-image.vercel.app/Goscript%20offical%20website.png?theme=light&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg" />
    <meta name="og:title" content="Goscript offical website" />
    <meta name="twitter:card" content="summary_large_image" />
    <title>Goscript Internals II: The Runtime, Part A</title>
    <meta name="next-head-count" content="8" />
    <link rel="preload" href="/_next/static/css/96f76011eaa949d6.css" as="style" />
    <link rel="stylesheet" href="/_next/static/css/96f76011eaa949d6.css" data-n-g="" />
    <link rel="preload" href="/_next/static/css/e07893e80d526a25.css" as="style" />
    <link rel="stylesheet" href="/_next/static/css/e07893e80d526a25.css" data-n-p="" /><noscript
        data-n-css=""></noscript>
    <script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script>
    <script src="/_next/static/chunks/webpack-c85490a6f758d8f5.js" defer=""></script>
    <script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script>
    <script src="/_next/static/chunks/main-ea86427ef25bef6d.js" defer=""></script>
    <script src="/_next/static/chunks/pages/_app-20c4a81707b11a34.js" defer=""></script>
    <script src="/_next/static/chunks/733-05d542b0b5535850.js" defer=""></script>
    <script src="/_next/static/chunks/pages/posts/%5Bid%5D-0f90271f7a4d1f3f.js" defer=""></script>
    <script src="/_next/static/n8qca7tfeduTvWxVWQ9cn/_buildManifest.js" defer=""></script>
    <script src="/_next/static/n8qca7tfeduTvWxVWQ9cn/_ssgManifest.js" defer=""></script>
</head>

<body>
    <div id="__next" data-reactroot="">
        <div class="layout_container__fbLkO">
            <nav class="navbar navbar-expand-lg navbar-light bg-light">
                <div class="container"><a href="/" class="navbar-brand"> <img src="/images/goscript-logo.jpeg"
                            width="45" height="45" class="utils_borderCircle__s2nTm" alt="goscript logo" /></a><button
                        aria-controls="basic-navbar-nav" type="button" aria-label="Toggle navigation"
                        class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button>
                    <div class="navbar-collapse collapse" id="basic-navbar-nav">
                        <div class="me-auto navbar-nav"><a href="/" data-rr-ui-event-key="/" class="nav-link">Home</a><a
                                href="/#blog-section" data-rr-ui-event-key="/#blog-section" class="nav-link">Blog</a><a
                                href="https://github.com/oxfeeefeee/goscript"
                                data-rr-ui-event-key="https://github.com/oxfeeefeee/goscript"
                                class="nav-link">Github</a></div>
                    </div>
                </div>
            </nav>
            <main>
                <article>
                    <h1 class="utils_headingXl__u25Y2">Goscript Internals II: The Runtime, Part A</h1>
                    <div class="utils_lightText__eUzGY"><a href="https://github.com/oxfeeefeee/">oxfeeefeee</a>
                        <a>2022-07-14</a></div>
                    <div>
                        <h2>Ingredients</h2>
                        <p>The <a href="https://goscript.dev/posts/goscript_internals_I_overview_en">previous
                                overview</a> promised a "relatively original wheel", however the runtime is in fact more
                            like a cocktail. Most of the ingredients are from Lua, Python Go and Rust.</p>
                        <ul>
                            <li>
                                <p>The VM and instruction design is inspired by Lua. Like Lua, Goscript has a
                                    register-based VM, and it also uses "upvalue" to support closure.</p>
                            </li>
                            <li>
                                <p>The memory management and GC is similar to Python's. Goscript uses reference counting
                                    and circular reference detection to reclaim memory.</p>
                            </li>
                            <li>
                                <p>To behave exactly like the official version of Go, the data structures have to
                                    simulate how they work originally, things like Interface and Slice.</p>
                            </li>
                            <li>
                                <p>To implement async features like goroutine and channel, async-await and channel from
                                    Rust ecosystem are used.</p>
                            </li>
                        </ul>
                        <h2>Instruction set</h2>
                        <p>Instructions <a
                                href="https://github.com/oxfeeefeee/goscript/blob/master/vm/src/instruction.rs">(instruction.rs)</a>
                            can be divided into five categories:</p>
                        <ul>
                            <li>
                                <p>Accessing. Copy between registers; access array/slice/map/upvalue/pointers.</p>
                            </li>
                            <li>
                                <p>Operation. Things like plus and minus, things denoted by operators.</p>
                            </li>
                            <li>
                                <p>Function call and return.</p>
                            </li>
                            <li>
                                <p>Jump.</p>
                            </li>
                            <li>
                                <p>Built-in functions. Both the implicitly used ones like BIND_METHOD, and the explicit
                                    ones like NEW and COPY.</p>
                            </li>
                        </ul>
                        <h2>Architecture of the VM</h2>
                        <p>Let's take a look again at the previous example:</p>
                        <div class="remark-highlight">
                            <pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">addN</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span><span class="token number">69</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">69</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">addN</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
    total <span class="token operator">:=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        total <span class="token operator">+=</span> m
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> total
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">mul</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> m <span class="token operator">*</span> n
<span class="token punctuation">}</span>
</code></pre>
                        </div>
                        <p>Below is a snapshot of the example running on the VM:
                            <img src="/images/vm_addn.jpeg" alt="vm_addn">
                            This diagram shows what's in the memory when <code>total += m</code> of <code>addN</code> is
                            being processed. On the left side is the loaded bytecode including the instructions and
                            consts, which are read only.
                        </p>
                        <p>The right side is more interesting. You should be no stranger to <a
                                href="https://en.wikipedia.org/wiki/Call_stack">call stack</a>, when <code>main</code>
                            and <code>addN</code> get called, <code>call frames</code> generated for them and pushed to
                            call stack, they'll be popped out when the functions return. Call frame is used to record
                            information about the running function including the most obvious one: <a
                                href="https://en.wikipedia.org/wiki/Program_counter">PC</a>.</p>
                        <p>Last but not least, the virtual registers. As the diagram shows, when a function is called, a
                            set of virtual registers are allocated for it in the following order:
                            <code>return value</code>, <code>arguments</code>, <code>local vars</code>,
                            <code>temporary vars</code>. Registers and consts are the only two places where instructions
                            can read from, and registers are the only place to write to.</p>
                        <p>For every step, the processing loop does the following:
                            Fetch the instruction that the PC of the active call frame on the top of the call stack
                            points to, and process it. Then the PC is either increased by 1, or modified to perform a
                            jump. If the instruction is a CALL / RETURN, the active call frame is changed.</p>
                        <p>This is when <code>m * n</code> of <code>mul</code> is being processed after
                            <code>addN</code> returned and <code>mul</code> is called:
                            <img src="/images/vm_mul.jpeg" alt="vm_mul">
                        </p>
                        <h2>Upvalue</h2>
                        <p>"The combination of lexical scoping with first-class functions creates a well-known
                            difficulty for accessing outer local variables". -- <a
                                href="https://www.lua.org/doc/sblp2005.pdf">《The Implementation of Lua 5.0》</a>.
                            Goscript steals the solution from Lua as it faces the same problem.</p>
                        <p>Here is an example:</p>
                        <div class="remark-highlight">
                            <pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token comment">// Returns a function that add 'up' to the input 'i'</span>
<span class="token keyword">func</span> <span class="token function">makeAdd</span><span class="token punctuation">(</span>up <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> up <span class="token operator">+</span> i
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    add42 <span class="token operator">:=</span> <span class="token function">makeAdd</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
    c <span class="token operator">:=</span> <span class="token function">add42</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
                        </div>
                        <p>Let's focus on <code>add42 := makeAdd(42)</code>, typically, when makeAdd returns, the
                            argument <code>42</code> is released, but in our case, it cannot be released as it's still
                            referenced by <code>add42</code>. Lua solve this by using a pointer that points to the
                            <code>up</code> value , hence the name. In the example, <code>add42</code> holds an upvalue
                            pointing to <code>42</code>.</p>
                        <p>The design of upvalue is relatively simple. When <code>makeAdd</code> is not returned yet,
                            the upvalue is just the address of <code>up</code> in the virtual registers, so both the
                            outer and the inner function can access it from the register. When <code>makeAdd</code>
                            returns, the value of <code>up</code> get copied to the heap, and the upvalue becomes a real
                            pointer pointing to the heap value.</p>
                        <p>The upvalue is <code>open</code> when <code>up</code> is still in the register, the upvalue
                            is <code>closed</code> when <code>up</code> is in the heap.</p>
                        <h2>Pointer</h2>
                        <p>It turns out upvalue can also be used elsewhere: pointers.</p>
                        <p>There is no VM-based language supports pointers as far as I know, but Goscript has to.
                            Luckily there are limitations for the use of pointers according to the <a
                                href="https://go.dev/ref/spec#Address_operators">Go specs</a>. Simply put, pointers can
                            only be created to point to certain things, for Goscript, they are:</p>
                        <ul>
                            <li>local variable</li>
                            <li>package member</li>
                            <li>slice member</li>
                            <li>struct field</li>
                        </ul>
                        <p>In Goscript, package, slice and struct are all stored in the heap, and we have real pointers
                            that point to them, so a combination of <code>(pointer, member_index)</code> is sufficient
                            to represent those three. For local variable, a pointer to it behaves exactly the same
                            as an upvalue, so it is implemented as an upvalue.</p>
                        <h2>Goroutine</h2>
                        <p>As the most iconic feature of Go, goroutine may seem complicated to implement, surprisingly,
                            it's not. Before look into the details of Goscript's coroutine, let's talk about coroutines
                            in general.</p>
                        <p>In terms of where you can yield, there are:</p>
                        <ul>
                            <li>Stackful coroutines, meaning they can yield and later resume freely</li>
                            <li>Stackless coroutines, meaning they can only yield back to the parent coroutine and later
                                get resumed by the parent coroutine.</li>
                        </ul>
                        <p>In terms of how coroutines cooperate with each other, there are:</p>
                        <ul>
                            <li>
                                <p>Preemptive coroutines, meaning busy coroutines get suspended by the scheduler once in
                                    a while to give other coroutines a chance.</p>
                            </li>
                            <li>
                                <p>Cooperative coroutines, meaning coroutines runs indefinitely until they explicitly
                                    yield.</p>
                            </li>
                        </ul>
                        <p>Go has a stackful preemptive coroutine system, which is also the most user friendly.</p>
                        <p>In Goscript, for every goroutine a processing loop is launched, which is an async function,
                            and an await can happen at any point inside the loop. Async Rust functions can also be
                            called inside the loop via Goscript FFI.</p>
                        <p>The loop yields after a certain amount of instructions are processed, so that the users don't need to
                             call yield explicitly, making the whole system preemptive.</p>
                        <p>With the help of Rust's async-await, we have a simple solution behind a powerful feature.
                            It's easier to understand from a different perspective: a goroutine is just a Rust future.
                        </p>
                        <h3>Coming up next</h3>
                        <p>Thera are a lot more Go features to cover in the runtime, I'm planning to finish them in the
                            next installment.</p>
                    </div>
                </article>
            </main>
            <div class="layout_backToHome__9sjx_"><a href="/">← Back to home</a></div>
        </div>
    </div>
    <script id="__NEXT_DATA__"
        type="application/json">{"props":{"pageProps":{"postData":{"id":"goscript_internals_II_the_runtime_a_en","contentHtml":"\u003ch2\u003eIngredients\u003c/h2\u003e\n\u003cp\u003eThe \u003ca href=\"https://goscript.dev/posts/goscript_internals_I_overview_en\"\u003eprevious overview\u003c/a\u003e promised a \"relatively original wheel\", however the runtime is in fact more like a cocktail. Most of the ingredients are from Lua, Python Go and Rust.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe VM and instruction design is inspired by Lua. Like Lua, Goscript has a register-based VM, and it also uses \"upvalue\" to support closure.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe memory management and GC is similar to Python's. Goscript uses reference counting and circular reference detection to reclaim memory.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTo behave exactly like the official version of Go, the data structures have to simulate how they work originally, things like Interface and Slice.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTo implement async features like goroutine and channel, async-await and channel from Rust ecosystem are used.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eInstruction set\u003c/h2\u003e\n\u003cp\u003eInstructions \u003ca href=\"https://github.com/oxfeeefeee/goscript/blob/master/vm/src/instruction.rs\"\u003e(instruction.rs)\u003c/a\u003e can be divided into five categories:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eAccessing. Copy between registers; access array/slice/map/upvalue/pointers.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eOperation. Things like plus and minus, things denoted by operators.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFunction call and return.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eJump.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eBuilt-in functions. Both the implicitly used ones like BIND_METHOD, and the explicit ones like NEW and COPY.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eArchitecture of the VM\u003c/h2\u003e\n\u003cp\u003eLet's take a look again at the previous example:\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-go\"\u003e\u003ccode class=\"language-go\"\u003e\u003cspan class=\"token keyword\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"token keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"token function\"\u003emain\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token function\"\u003eassert\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token function\"\u003eaddN\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token number\"\u003e42\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\u003cspan class=\"token number\"\u003e69\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e==\u003c/span\u003e \u003cspan class=\"token function\"\u003emul\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token number\"\u003e42\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e69\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"token keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"token function\"\u003eaddN\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003em\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e n \u003cspan class=\"token builtin\"\u003eint\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eint\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    total \u003cspan class=\"token operator\"\u003e:=\u003c/span\u003e \u003cspan class=\"token number\"\u003e0\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"token operator\"\u003e:=\u003c/span\u003e\u003cspan class=\"token number\"\u003e0\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e i \u003cspan class=\"token operator\"\u003e\u0026#x3C;\u003c/span\u003e n\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e i\u003cspan class=\"token operator\"\u003e++\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n        total \u003cspan class=\"token operator\"\u003e+=\u003c/span\u003e m\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e total\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"token keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"token function\"\u003emul\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003em\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e n \u003cspan class=\"token builtin\"\u003eint\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eint\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e m \u003cspan class=\"token operator\"\u003e*\u003c/span\u003e n\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eBelow is a snapshot of the example running on the VM:\n\u003cimg src=\"/images/vm_addn.jpeg\" alt=\"vm_addn\"\u003e\nThis diagram shows what's in the memory when \u003ccode\u003etotal += m\u003c/code\u003e of \u003ccode\u003eaddN\u003c/code\u003e is being processed. On the left side is the loaded bytecode including the instructions and consts, which are read only.\u003c/p\u003e\n\u003cp\u003eThe right side is more interesting. You should be no stranger to \u003ca href=\"https://en.wikipedia.org/wiki/Call_stack\"\u003ecall stack\u003c/a\u003e, when \u003ccode\u003emain\u003c/code\u003e and \u003ccode\u003eaddN\u003c/code\u003e get called, \u003ccode\u003ecall frames\u003c/code\u003e generated for them and pushed to call stack, they'll be popped out when the functions return. Call frame is used to record information about the running function including the most obvious one: \u003ca href=\"https://en.wikipedia.org/wiki/Program_counter\"\u003ePC\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eLast but not least, the virtual registers. As the diagram shows, when a function is called, a set of virtual registers are allocated for it in the following order: \u003ccode\u003ereturn value\u003c/code\u003e, \u003ccode\u003earguments\u003c/code\u003e, \u003ccode\u003elocal vars\u003c/code\u003e, \u003ccode\u003etemporary vars\u003c/code\u003e. Registers and consts are the only two places where instructions can read from, and registers are the only place to write to.\u003c/p\u003e\n\u003cp\u003eFor every step, the processing loop does the following:\nFetch the instruction that the PC of the active call frame on the top of the call stack points to, and process it. Then the PC is either increased by 1, or modified to perform a jump. If the instruction is a CALL / RETURN, the active call frame is changed.\u003c/p\u003e\n\u003cp\u003eThis is when \u003ccode\u003em * n\u003c/code\u003e of \u003ccode\u003emul\u003c/code\u003e is being processed after \u003ccode\u003eaddN\u003c/code\u003e returned and \u003ccode\u003emul\u003c/code\u003e is callded:\n\u003cimg src=\"/images/vm_mul.jpeg\" alt=\"vm_mul\"\u003e\u003c/p\u003e\n\u003ch2\u003eUpvalue\u003c/h2\u003e\n\u003cp\u003e\"The combination of lexical scoping with first-class functions creates a well-known difficulty for accessing outer local variables\". -- \u003ca href=\"https://www.lua.org/doc/sblp2005.pdf\"\u003e《The Implementation of Lua 5.0》\u003c/a\u003e. Goscript steals the solution from Lua as it faces the same problem.\u003c/p\u003e\n\u003cp\u003eHere is an example:\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-go\"\u003e\u003ccode class=\"language-go\"\u003e\u003cspan class=\"token keyword\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"token keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"fmt\"\u003c/span\u003e\n\n\u003cspan class=\"token comment\"\u003e// Returns a function that add 'up' to the input 'i'\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"token function\"\u003emakeAdd\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eup \u003cspan class=\"token builtin\"\u003eint\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token builtin\"\u003eint\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eint\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ei \u003cspan class=\"token builtin\"\u003eint\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eint\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e up \u003cspan class=\"token operator\"\u003e+\u003c/span\u003e i\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"token keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"token function\"\u003emain\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    add42 \u003cspan class=\"token operator\"\u003e:=\u003c/span\u003e \u003cspan class=\"token function\"\u003emakeAdd\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token number\"\u003e42\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n    c \u003cspan class=\"token operator\"\u003e:=\u003c/span\u003e \u003cspan class=\"token function\"\u003eadd42\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n    fmt\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ePrintln\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ec\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eLet's focus on \u003ccode\u003eadd42 := makeAdd(42)\u003c/code\u003e, typically, when makeAdd returns, the argument \u003ccode\u003e42\u003c/code\u003e is released, but in our case, it cannot be released as it's still referenced by \u003ccode\u003eadd42\u003c/code\u003e. Lua solve this by using a pointer that points to the \u003ccode\u003eup\u003c/code\u003e value , hence the name. In the example, \u003ccode\u003eadd42\u003c/code\u003e holds an upvalue pointing to \u003ccode\u003e42\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe design of upvalue is relatively simple. When \u003ccode\u003emakeAdd\u003c/code\u003e is not returned yet, the upvalue is just the address of \u003ccode\u003eup\u003c/code\u003e in the virtual registers, so both the outer and the inner function can access it from the register. When \u003ccode\u003emakeAdd\u003c/code\u003e returns, the value of \u003ccode\u003eup\u003c/code\u003e get copied to the heap, and the upvalue becomes a real pointer pointing to the heap value.\u003c/p\u003e\n\u003cp\u003eThe upvalue is \u003ccode\u003eopen\u003c/code\u003e when \u003ccode\u003eup\u003c/code\u003e is still in the register, the upvalue is \u003ccode\u003eclosed\u003c/code\u003e when \u003ccode\u003eup\u003c/code\u003e is in the heap.\u003c/p\u003e\n\u003ch2\u003ePointer\u003c/h2\u003e\n\u003cp\u003eIt turns out upvalue can also be used elsewhere: pointers.\u003c/p\u003e\n\u003cp\u003eThere is no VM-based language supports pointers as far as I know, but Goscript has to. Luckily there are limitations for the use of pointers according to the \u003ca href=\"https://go.dev/ref/spec#Address_operators\"\u003eGo specs\u003c/a\u003e. Simply put, pointers can only be created to point to certain things, for Goscript, they are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003elocal variable\u003c/li\u003e\n\u003cli\u003epackage member\u003c/li\u003e\n\u003cli\u003eslice member\u003c/li\u003e\n\u003cli\u003estruct field\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn Goscript, package, slice and struct are all stored in the heap, and we have real pointers that point to them, so a combination of \u003ccode\u003e(pointer, member_index)\u003c/code\u003e is sufficient to represent the those three. For local variable, a pointer to it behaves exactly the same as an upvalue, so it is implemented as an upvalue.\u003c/p\u003e\n\u003ch2\u003eGoroutine\u003c/h2\u003e\n\u003cp\u003eAs the most iconic feature of Go, goroutine may seem complicated to implement, surprisingly, it's not. Before look into the details of Goscript's coroutine, let's talk about coroutines in general.\u003c/p\u003e\n\u003cp\u003eIn terms of where you can yield, there are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eStackful coroutines, meaning they can yield and later resume freely\u003c/li\u003e\n\u003cli\u003eStackless coroutines, meaning they can only yield back to the parent coroutine and later get resumed by the parent coroutine.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn terms of how coroutines cooperate with each other, there are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ePreemptive coroutines, meaning busy coroutines get suspended by the scheduler once in a while to give other coroutines a chance.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCooperative coroutines, meaning coroutines runs indefinitely until they explicitly yield.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eGo has a stackful preemptive coroutine system, which is also the most user friendly.\u003c/p\u003e\n\u003cp\u003eIn Goscript, for every goroutine a processing loop is launched, which is an async function, and an await can happen at any point inside the loop. Async Rust functions can also be called inside the loop via Goscript FFI.\u003c/p\u003e\n\u003cp\u003eTo be cooperative, the loop yields after a certain amount of instructions are processed.\u003c/p\u003e\n\u003cp\u003eWith the help of Rust's async-await, we have a simple solution behind a powerful feature. It's easier to understand from a different perspective: a goroutine is just a Rust future.\u003c/p\u003e\n\u003ch3\u003eComing up next\u003c/h3\u003e\n\u003cp\u003eThera are a lot more Go features to cover in the runtime, I'm planning to finish them in the next installment.\u003c/p\u003e\n","title":"Goscript Internals II: The Runtime, Part A","date":"2022-07-14"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"goscript_internals_II_the_runtime_a_en"},"buildId":"n8qca7tfeduTvWxVWQ9cn","isFallback":false,"gsp":true,"scriptLoader":[]}</script>
</body>

</html>